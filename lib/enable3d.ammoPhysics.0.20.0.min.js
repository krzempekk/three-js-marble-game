!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],e):"object"==typeof exports?exports.ENABLE3D=e(require("THREE")):t.ENABLE3D=e(t.THREE)}(window,(function(t){return function(t){var e={};function s(o){if(e[o])return e[o].exports;var n=e[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,s),n.l=!0,n.exports}return s.m=t,s.c=e,s.d=function(t,e,o){s.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},s.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(s.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)s.d(o,n,function(e){return t[e]}.bind(null,n));return o},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,"a",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p="",s(s.s=16)}([function(e,s){e.exports=t},function(t,e,s){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=t=>{console.error(`%c [enable3d] ${t} `,"background: #222; color: #bada55")}},function(t,e,s){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0}),e.ExtendedObject3D=void 0;const o=s(0);class n extends o.Object3D{constructor(){super(),this.vector3=new o.Vector3,this.isGroup=!1,this.hasBody=!1,this.anims={},this._currentAnimation="",this._animationActions=new Map,this.name="object-"+this.id}setAction(t){console.warn("[enable3d] setAction(name) is deprecated. Use animation.play(name) instead!"),this.animationPlay(t)}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}get animation(){return{current:this._currentAnimation,add:(t,e)=>this.animationAdd(t,e),play:(t,e=500,s=!0)=>this.animationPlay(t,e,s),mixer:this.animationMixer}}set animationMixer(t){this._animationMixer=t}get animationMixer(){return this._animationMixer||(this._animationMixer=new o.AnimationMixer(this)),this._animationMixer}animationAdd(t,e){this._animationActions.set(t,this.animationMixer.clipAction(e))}animationPlay(t,e=500,s=!0){const n=this._animationActions.get(t),i=this._animationActions.get(this._currentAnimation);n&&(n.reset(),i&&(n.crossFadeFrom(i,e/1e3,!0),n.clampWhenFinished=!0),s||n.setLoop(o.LoopOnce,0),n.play()),this._currentAnimation=t}}e.ExtendedObject3D=n,e.default=n},function(t,e,s){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0}),e.ExtendedMesh=void 0;const o=s(0);class n extends o.Mesh{constructor(t,e){super(t,e),this.vector3=new o.Vector3,this.isGroup=!1,this.hasBody=!1,this.name="object-"+this.id}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}e.ExtendedMesh=n},function(t,e,s){"use strict";var o=Object.prototype.hasOwnProperty,n="~";function i(){}function r(t,e,s){this.fn=t,this.context=e,this.once=s||!1}function a(t,e,s,o,i){if("function"!=typeof s)throw new TypeError("The listener must be a function");var a=new r(s,o||t,i),c=n?n+e:e;return t._events[c]?t._events[c].fn?t._events[c]=[t._events[c],a]:t._events[c].push(a):(t._events[c]=a,t._eventsCount++),t}function c(t,e){0==--t._eventsCount?t._events=new i:delete t._events[e]}function l(){this._events=new i,this._eventsCount=0}Object.create&&(i.prototype=Object.create(null),(new i).__proto__||(n=!1)),l.prototype.eventNames=function(){var t,e,s=[];if(0===this._eventsCount)return s;for(e in t=this._events)o.call(t,e)&&s.push(n?e.slice(1):e);return Object.getOwnPropertySymbols?s.concat(Object.getOwnPropertySymbols(t)):s},l.prototype.listeners=function(t){var e=n?n+t:t,s=this._events[e];if(!s)return[];if(s.fn)return[s.fn];for(var o=0,i=s.length,r=new Array(i);o<i;o++)r[o]=s[o].fn;return r},l.prototype.listenerCount=function(t){var e=n?n+t:t,s=this._events[e];return s?s.fn?1:s.length:0},l.prototype.emit=function(t,e,s,o,i,r){var a=n?n+t:t;if(!this._events[a])return!1;var c,l,m=this._events[a],h=arguments.length;if(m.fn){switch(m.once&&this.removeListener(t,m.fn,void 0,!0),h){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,e),!0;case 3:return m.fn.call(m.context,e,s),!0;case 4:return m.fn.call(m.context,e,s,o),!0;case 5:return m.fn.call(m.context,e,s,o,i),!0;case 6:return m.fn.call(m.context,e,s,o,i,r),!0}for(l=1,c=new Array(h-1);l<h;l++)c[l-1]=arguments[l];m.fn.apply(m.context,c)}else{var d,u=m.length;for(l=0;l<u;l++)switch(m[l].once&&this.removeListener(t,m[l].fn,void 0,!0),h){case 1:m[l].fn.call(m[l].context);break;case 2:m[l].fn.call(m[l].context,e);break;case 3:m[l].fn.call(m[l].context,e,s);break;case 4:m[l].fn.call(m[l].context,e,s,o);break;default:if(!c)for(d=1,c=new Array(h-1);d<h;d++)c[d-1]=arguments[d];m[l].fn.apply(m[l].context,c)}}return!0},l.prototype.on=function(t,e,s){return a(this,t,e,s,!1)},l.prototype.once=function(t,e,s){return a(this,t,e,s,!0)},l.prototype.removeListener=function(t,e,s,o){var i=n?n+t:t;if(!this._events[i])return this;if(!e)return c(this,i),this;var r=this._events[i];if(r.fn)r.fn!==e||o&&!r.once||s&&r.context!==s||c(this,i);else{for(var a=0,l=[],m=r.length;a<m;a++)(r[a].fn!==e||o&&!r[a].once||s&&r[a].context!==s)&&l.push(r[a]);l.length?this._events[i]=1===l.length?l[0]:l:c(this,i)}return this},l.prototype.removeAllListeners=function(t){var e;return t?(e=n?n+t:t,this._events[e]&&c(this,e)):(this._events=new i,this._eventsCount=0),this},l.prototype.off=l.prototype.removeListener,l.prototype.addListener=l.prototype.on,l.prefixed=n,l.EventEmitter=l,t.exports=l},function(t,e,s){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const o=s(0);e.default=class{constructor(){this._defaultMaterial=new o.MeshLambertMaterial({color:13421772})}get(){return this._defaultMaterial}}},function(t,e,s){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=(t,e)=>{e.forEach(e=>{Object.getOwnPropertyNames(e.prototype).forEach(s=>{Object.defineProperty(t.prototype,s,Object.getOwnPropertyDescriptor(e.prototype,s))})})}},function(t,e,s){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0}),e.ExtendedGroup=void 0;const o=s(0);class n extends o.Group{constructor(){super(),this.isMesh=!1,this.hasBody=!1,this.name="object-"+this.id}}e.ExtendedGroup=n},function(t,e,s){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.PhysicsLoader=void 0;const o=s(15);e.PhysicsLoader=(t,e)=>{"undefined"!=typeof window&&(window.__loadPhysics=!0),o.default(t,()=>{Ammo().then(()=>{e()})})}},function(t,e,s){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0}),e.ExtendedMesh=e.ExtendedObject3D=void 0;const o=s(2);Object.defineProperty(e,"ExtendedObject3D",{enumerable:!0,get:function(){return o.ExtendedObject3D}});const n=s(3);Object.defineProperty(e,"ExtendedMesh",{enumerable:!0,get:function(){return n.ExtendedMesh}});var i=s(0);Object.defineProperty(e,"AnimationMixer",{enumerable:!0,get:function(){return i.AnimationMixer}}),Object.defineProperty(e,"AnimationClip",{enumerable:!0,get:function(){return i.AnimationClip}}),Object.defineProperty(e,"AnimationAction",{enumerable:!0,get:function(){return i.AnimationAction}}),Object.defineProperty(e,"Object3D",{enumerable:!0,get:function(){return i.Object3D}}),Object.defineProperty(e,"Mesh",{enumerable:!0,get:function(){return i.Mesh}}),Object.defineProperty(e,"Material",{enumerable:!0,get:function(){return i.Material}}),Object.defineProperty(e,"Line",{enumerable:!0,get:function(){return i.Line}}),Object.defineProperty(e,"Points",{enumerable:!0,get:function(){return i.Points}}),Object.defineProperty(e,"Group",{enumerable:!0,get:function(){return i.Group}})},function(t,e,s){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0});const o=s(14),n=s(0);e.default=class{constructor(t,e){this.physics=t,this.ammo=e,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.breakable=!1,this.didUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new n.Euler,this.tmpQuaternion=new n.Quaternion,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new o.EventEmitter,this.name=e.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion)}setupEventEmitter(){void 0===this.eventEmitter&&(this.eventEmitter=new o.EventEmitter)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,e=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,e?this.eventEmitter.once("update",()=>{t()}):this.eventEmitter.on("update",()=>{t()})}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",e=>{const{bodies:s,event:o}=e;s[0].name===this.name?t(s[1],o):s[1].name===this.name&&t(s[0],o)})}transform(){const t=this.physics.tmpTrans;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.tmpTrans;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,e,s){const o=this.tmpEuler.set(t,e,s),n=this.tmpQuaternion.set(0,0,0,1);n.setFromEuler(o),this.tmpBtQuaternion.setValue(0,0,0,1);const i=this.tmpBtQuaternion;i.setValue(n.x,n.y,n.z,n.w);this.physics.tmpTrans.setRotation(i)}get rotation(){const t=this.physics.tmpTrans.getRotation(),e=this.tmpQuaternion.set(t.x(),t.y(),t.z(),t.w()),s=e.x,o=e.y,n=e.z,i=e.w,r=2*Math.acos(i);return{x:s/Math.sqrt(1-i*i)*r||0,y:o/Math.sqrt(1-i*i)*r||0,z:n/Math.sqrt(1-i*i)*r||0}}setPosition(t,e,s){this.physics.tmpTrans.getOrigin().setValue(t,e,s)}get position(){const t=this.physics.tmpTrans;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,e){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(e.x||0,e.y||0,e.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setGravity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}}},function(t,e,s){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */var o=this&&this.__rest||function(t,e){var s={};for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&e.indexOf(o)<0&&(s[o]=t[o]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(o=Object.getOwnPropertySymbols(t);n<o.length;n++)e.indexOf(o[n])<0&&Object.prototype.propertyIsEnumerable.call(t,o[n])&&(s[o[n]]=t[o[n]])}return s};Object.defineProperty(e,"__esModule",{value:!0});const n=s(0),i=s(3),r=s(1),a=s(5);e.default=class{constructor(t){this.scene=t,this.isHeadless="headless"===t,this.defaultMaterial=new a.default}get make(){return{plane:(t={},e={})=>this.makePlane(t,e),box:(t={},e={})=>this.makeBox(t,e),sphere:(t={},e={})=>this.makeSphere(t,e),cylinder:(t={},e={})=>this.makeCylinder(t,e),cone:(t={},e={})=>this.makeCone(t,e),torus:(t={},e={})=>this.makeTorus(t,e),extrude:(t,e={})=>this.makeExtrude(t,e)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},e={})=>this.addPlane(t,e),box:(t={},e={})=>this.addBox(t,e),ground:(t,e={})=>this.addGround(t,e),sphere:(t={},e={})=>this.addSphere(t,e),cylinder:(t={},e={})=>this.addCylinder(t,e),cone:(t={},e={})=>this.addCone(t,e),torus:(t={},e={})=>this.addTorus(t,e),extrude:(t,e={})=>this.addExtrude(t,e),material:(t={})=>this.addMaterial(t)}}addExisting(...t){"headless"!==this.scene&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let e=0;e<t.length;e++)this.addExisting(t[e]);else this.addExisting(t);return this}createMesh(t,e,s){const{x:o=0,y:r=0,z:a=0}=s;let c;switch(!Array.isArray(e)&&e.type){case"LineBasicMaterial":c=new n.Line(t,e);break;case"PointsMaterial":c=new n.Points(t,e);break;default:c=new i.ExtendedMesh(t,e)}return c.position.set(o,r,a),c.castShadow=c.receiveShadow=!0,c}makeExtrude(t,e){const{x:s,y:i,z:r,name:a,shape:c,autoCenter:l=!0,breakable:m=!1,bufferGeometry:h=!0}=t,d=o(t,["x","y","z","name","shape","autoCenter","breakable","bufferGeometry"]),{depth:u=1,bevelEnabled:p=!1}=d,y=h||m||this.isHeadless?new n.ExtrudeBufferGeometry(c,Object.assign({depth:u,bevelEnabled:p},d)):new n.ExtrudeGeometry(c,Object.assign({depth:u,bevelEnabled:p},d)),f=this.addMaterial(e),b=this.createMesh(y,f,{x:s,y:i,z:r});return l&&b.geometry.center(),b.name=a||"body_id_"+b.id,b.shape="extrude",b}addExtrude(t,e={}){const s=this.makeExtrude(t,e);return this.addExisting(s),s}makePlane(t,e){const{x:s,y:i,z:r,name:a,breakable:c=!1,bufferGeometry:l=!0}=t,m=o(t,["x","y","z","name","breakable","bufferGeometry"]),h=l||c||this.isHeadless?new n.PlaneBufferGeometry(m.width||1,m.height||1,m.widthSegments||1,m.heightSegments||1):new n.PlaneGeometry(m.width||1,m.height||1,m.widthSegments||1,m.heightSegments||1),d=this.addMaterial(e);d.side=n.DoubleSide;const u=this.createMesh(h,d,{x:s,y:i,z:r});return u.name=a||"body_id_"+u.id,u.shape="plane",u}addPlane(t,e){const s=this.makePlane(t,e);return this.addExisting(s),s}makeSphere(t,e){const{x:s,y:i,z:r,name:a,breakable:c=!1,bufferGeometry:l=!0}=t,m=o(t,["x","y","z","name","breakable","bufferGeometry"]),h=l||c||this.isHeadless?new n.SphereBufferGeometry(m.radius||1,m.widthSegments||16,m.heightSegments||12,m.phiStart||void 0,m.phiLength||void 0,m.thetaStart||void 0,m.thetaLength||void 0):new n.SphereGeometry(m.radius||1,m.widthSegments||16,m.heightSegments||12,m.phiStart||void 0,m.phiLength||void 0,m.thetaStart||void 0,m.thetaLength||void 0),d=this.addMaterial(e),u=this.createMesh(h,d,{x:s,y:i,z:r});return u.name=a||"body_id_"+u.id,u.shape="sphere",u}addSphere(t={},e={}){const s=this.makeSphere(t,e);return this.addExisting(s),s}makeBox(t,e){const{x:s,y:i,z:r,name:a,breakable:c=!1,bufferGeometry:l=!0}=t,m=o(t,["x","y","z","name","breakable","bufferGeometry"]),h=l||c||this.isHeadless?new n.BoxBufferGeometry(m.width||1,m.height||1,m.depth||1,m.widthSegments||void 0,m.heightSegments||void 0,m.depthSegments||void 0):new n.BoxGeometry(m.width||1,m.height||1,m.depth||1,m.widthSegments||void 0,m.heightSegments||void 0,m.depthSegments||void 0),d=this.addMaterial(e),u=this.createMesh(h,d,{x:s,y:i,z:r});return u.name=a||"body_id_"+u.id,u.shape="box",u}addBox(t={},e={}){const s=this.makeBox(t,e);return this.addExisting(s),s}addGround(t,e={}){const s=this.makeBox(t,e);return s.rotateX(n.MathUtils.degToRad(90)),this.addExisting(s),s}makeCylinder(t={},e={}){const{x:s,y:i,z:r,name:a,breakable:c=!1,bufferGeometry:l=!0}=t,m=o(t,["x","y","z","name","breakable","bufferGeometry"]),h=l||c||this.isHeadless?new n.CylinderBufferGeometry(m.radiusTop||1,m.radiusBottom||1,m.height||1,m.radiusSegments||void 0,m.heightSegments||void 0,m.openEnded||void 0,m.thetaStart||void 0,m.thetaLength||void 0):new n.CylinderGeometry(m.radiusTop||1,m.radiusBottom||1,m.height||1,m.radiusSegments||void 0,m.heightSegments||void 0,m.openEnded||void 0,m.thetaStart||void 0,m.thetaLength||void 0),d=this.addMaterial(e),u=this.createMesh(h,d,{x:s,y:i,z:r});return u.name=a||"body_id_"+u.id,u.shape="cylinder",u}addCylinder(t={},e={}){const s=this.makeCylinder(t,e);return this.addExisting(s),s}makeCone(t={},e={}){const{x:s,y:i,z:r,name:a,breakable:c=!1,bufferGeometry:l=!0}=t,m=o(t,["x","y","z","name","breakable","bufferGeometry"]),h=(l||c||this.isHeadless,new n.ConeBufferGeometry(m.radius||1,m.height||1,m.radiusSegments||8,m.heightSegments||1,m.openEnded||!1,m.thetaStart||0,m.thetaLength||2*Math.PI)),d=this.addMaterial(e),u=this.createMesh(h,d,{x:s,y:i,z:r});return u.name=a||"body_id_"+u.id,u.shape="cone",u}addCone(t={},e={}){const s=this.makeCone(t,e);return this.addExisting(s),s}makeTorus(t={},e={}){const{x:s,y:i,z:r,name:a,breakable:c=!1,bufferGeometry:l=!0}=t,m=o(t,["x","y","z","name","breakable","bufferGeometry"]),h=l||c||this.isHeadless?new n.TorusBufferGeometry(m.radius||void 0,m.tube||void 0,m.radialSegments||void 0,m.tubularSegments||void 0,m.arc||void 0):new n.TorusGeometry(m.radius||void 0,m.tube||void 0,m.radialSegments||void 0,m.tubularSegments||void 0,m.arc||void 0),d=this.addMaterial(e),u=this.createMesh(h,d,{x:s,y:i,z:r});return u.name=a||"body_id_"+u.id,u.shape="torus",u}addTorus(t={},e={}){const s=this.makeTorus(t,e);return this.addExisting(s),s}addMaterial(t={}){const e=Object.keys(t)[0];let s;if("headless"===this.scene)return this.defaultMaterial.get();switch(e){case"basic":s=new n.MeshBasicMaterial(t.basic);break;case"normal":s=new n.MeshNormalMaterial(t.normal);break;case"standard":s=new n.MeshStandardMaterial(t.standard);break;case"lambert":s=new n.MeshLambertMaterial(t.lambert);break;case"phong":s=new n.MeshPhongMaterial(t.phong);break;case"physical":void 0!==t.physical?s=new n.MeshPhysicalMaterial(t.physical):(r.default("You need to pass parameters to the physical material. (Fallback to default material)"),s=this.defaultMaterial.get());break;case"toon":s=new n.MeshToonMaterial(t.toon);break;case"line":s=new n.LineBasicMaterial(t.line);break;case"points":s=new n.PointsMaterial(t.points);break;case"custom":s=t.custom||this.defaultMaterial.get();break;default:s=this.defaultMaterial.get()}return s}}},function(t,e,s){},function(t,e,s){},function(t,e,s){"use strict";var o=Object.prototype.hasOwnProperty,n="~";function i(){}function r(t,e,s){this.fn=t,this.context=e,this.once=s||!1}function a(t,e,s,o,i){if("function"!=typeof s)throw new TypeError("The listener must be a function");var a=new r(s,o||t,i),c=n?n+e:e;return t._events[c]?t._events[c].fn?t._events[c]=[t._events[c],a]:t._events[c].push(a):(t._events[c]=a,t._eventsCount++),t}function c(t,e){0==--t._eventsCount?t._events=new i:delete t._events[e]}function l(){this._events=new i,this._eventsCount=0}Object.create&&(i.prototype=Object.create(null),(new i).__proto__||(n=!1)),l.prototype.eventNames=function(){var t,e,s=[];if(0===this._eventsCount)return s;for(e in t=this._events)o.call(t,e)&&s.push(n?e.slice(1):e);return Object.getOwnPropertySymbols?s.concat(Object.getOwnPropertySymbols(t)):s},l.prototype.listeners=function(t){var e=n?n+t:t,s=this._events[e];if(!s)return[];if(s.fn)return[s.fn];for(var o=0,i=s.length,r=new Array(i);o<i;o++)r[o]=s[o].fn;return r},l.prototype.listenerCount=function(t){var e=n?n+t:t,s=this._events[e];return s?s.fn?1:s.length:0},l.prototype.emit=function(t,e,s,o,i,r){var a=n?n+t:t;if(!this._events[a])return!1;var c,l,m=this._events[a],h=arguments.length;if(m.fn){switch(m.once&&this.removeListener(t,m.fn,void 0,!0),h){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,e),!0;case 3:return m.fn.call(m.context,e,s),!0;case 4:return m.fn.call(m.context,e,s,o),!0;case 5:return m.fn.call(m.context,e,s,o,i),!0;case 6:return m.fn.call(m.context,e,s,o,i,r),!0}for(l=1,c=new Array(h-1);l<h;l++)c[l-1]=arguments[l];m.fn.apply(m.context,c)}else{var d,u=m.length;for(l=0;l<u;l++)switch(m[l].once&&this.removeListener(t,m[l].fn,void 0,!0),h){case 1:m[l].fn.call(m[l].context);break;case 2:m[l].fn.call(m[l].context,e);break;case 3:m[l].fn.call(m[l].context,e,s);break;case 4:m[l].fn.call(m[l].context,e,s,o);break;default:if(!c)for(d=1,c=new Array(h-1);d<h;d++)c[d-1]=arguments[d];m[l].fn.apply(m[l].context,c)}}return!0},l.prototype.on=function(t,e,s){return a(this,t,e,s,!1)},l.prototype.once=function(t,e,s){return a(this,t,e,s,!0)},l.prototype.removeListener=function(t,e,s,o){var i=n?n+t:t;if(!this._events[i])return this;if(!e)return c(this,i),this;var r=this._events[i];if(r.fn)r.fn!==e||o&&!r.once||s&&r.context!==s||c(this,i);else{for(var a=0,l=[],m=r.length;a<m;a++)(r[a].fn!==e||o&&!r[a].once||s&&r[a].context!==s)&&l.push(r[a]);l.length?this._events[i]=1===l.length?l[0]:l:c(this,i)}return this},l.prototype.removeAllListeners=function(t){var e;return t?(e=n?n+t:t,this._events[e]&&c(this,e)):(this._events=new i,this._eventsCount=0),this},l.prototype.off=l.prototype.removeListener,l.prototype.addListener=l.prototype.on,l.prefixed=n,l.EventEmitter=l,t.exports=l},function(t,e,s){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const o=(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const t=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(t instanceof WebAssembly.Module)return new WebAssembly.Instance(t)instanceof WebAssembly.Instance}}catch(t){}return!1})(),n=(t,e)=>{var s=document.createElement("script");s.onload=()=>{e()},s.onerror=()=>{throw new Error("failed to load "+t)},s.async=!0,s.src=t,document.head.appendChild(s)};e.default=(t,e)=>{n(o?t+"/ammo.wasm.js":t+"/ammo.js",()=>e())}},function(t,e,s){"use strict";s.r(e),s.d(e,"ExtendedObject3D",(function(){return a.ExtendedObject3D})),s.d(e,"ExtendedMesh",(function(){return l.ExtendedMesh})),s.d(e,"ExtendedGroup",(function(){return m.ExtendedGroup})),s.d(e,"PhysicsLoader",(function(){return et.PhysicsLoader})),s.d(e,"ClosestRaycaster",(function(){return ct})),s.d(e,"AllHitsRaycaster",(function(){return lt})),s.d(e,"Types",(function(){return nt})),s.d(e,"Clock",(function(){return mt})),s.d(e,"AmmoPhysics",(function(){return ht}));s(12),s(13);var o=s(1),n=s.n(o),i=s(10),r=s.n(i),a=s(2),c=s.n(a),l=s(3),m=s(7);var h=
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
class{constructor(t,e){this.factory=t,this.addExisting=e}addPlane(t={},e={}){const s=this.factory.add.plane(t,e);return this.addExisting(s,t),s}addSphere(t={},e={}){const s=this.factory.add.sphere(t,e);return this.addExisting(s,t),s}addBox(t={},e={}){const s=this.factory.add.box(t,e);return this.addExisting(s,t),s}addGround(t,e={}){const s=this.factory.add.ground(t,e),o=Object.assign(Object.assign({},t),{mass:0,collisionFlags:1});return this.addExisting(s,o),s}addCylinder(t={},e={}){const s=this.factory.add.cylinder(t,e);return this.addExisting(s,t),s}addCone(t={},e={}){const s=this.factory.add.cone(t,e);return this.addExisting(s,t),s}addTorus(t={},e={}){const s=this.factory.add.torus(t,e);return this.addExisting(s,t),s}addExtrude(t,e={}){const s=this.factory.add.extrude(t,e);return s.translateX(1),this.addExisting(s),s}};
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class d{constructor(t,e){this.tmpTrans=t,this.physicsWorld=e,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(t,e=0){return new Ammo.btVector3(void 0!==(null==t?void 0:t.x)?t.x:e,void 0!==(null==t?void 0:t.y)?t.y:e,void 0!==(null==t?void 0:t.z)?t.z:e)}get addConstraints(){return{lock:(t,e)=>this.lock(t,e),fixed:(t,e)=>this.fixed(t,e),pointToPoint:(t,e,s)=>this.pointToPoint(t,e,s),hinge:(t,e,s)=>this.hinge(t,e,s),slider:(t,e,s={})=>this.slider(t,e,s),spring:(t,e,s={})=>this.spring(t,e,s),coneTwist:(t,e,s={},o={})=>this.coneTwist(t,e,s,o),dof:(t,e,s)=>this.dof(t,e,s)}}getTransform(t,e,s={x:0,y:0,z:0},o=!1){s=Object.assign({x:0,y:0,z:0},s);const n=new Ammo.btTransform;if(n.setIdentity(),o){const o=(i=t.getWorldTransform().getOrigin(),r=e.getWorldTransform().getOrigin(),a=(i.x()-r.x())/2+s.x,c=(i.y()-r.y())/2+s.y,l=(i.z()-r.z())/2+s.z,new Ammo.btVector3(a,c,l)),n=new Ammo.btTransform;n.setIdentity(),n.setOrigin(o);const m=t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());return m.op_mul(n),{transformA:m,transformB:n}}n.setOrigin(new Ammo.btVector3(s.x,s.y,s.z));return{transformA:t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(n),transformB:n};var i,r,a,c,l}lock(t,e){const s={x:0,y:0,z:0};return this.dof(t,e,{angularLowerLimit:s,angularUpperLimit:s})}fixed(t,e){const s=this.getTransform(t.ammo,e.ammo);s.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),s.transformB.setRotation(e.ammo.getWorldTransform().getRotation());const o=new Ammo.btFixedConstraint(t.ammo,e.ammo,s.transformA,s.transformB);return this.physicsWorld.addConstraint(o),o}pointToPoint(t,e,s={}){const{pivotA:o,pivotB:n}=s,i=new Ammo.btVector3((null==o?void 0:o.x)||0,(null==o?void 0:o.y)||0,(null==o?void 0:o.z)||0),r=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),a=new Ammo.btPoint2PointConstraint(t.ammo,e.ammo,i,r);return this.physicsWorld.addConstraint(a),a}hinge(t,e,s={}){const{pivotA:o,pivotB:n,axisA:i,axisB:r}=s,a=new Ammo.btVector3((null==o?void 0:o.x)||0,(null==o?void 0:o.y)||0,(null==o?void 0:o.z)||0),c=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),l=new Ammo.btVector3((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0),m=new Ammo.btVector3((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),h=new Ammo.btHingeConstraint(t.ammo,e.ammo,a,c,l,m,!0);return this.physicsWorld.addConstraint(h),h}slider(t,e,s={}){const o=this.getTransform(t.ammo,e.ammo),{frameA:n={},frameB:i={},linearLowerLimit:r=0,linearUpperLimit:a=0,angularLowerLimit:c=0,angularUpperLimit:l=0}=s,m=o.transformA.getRotation();m.setEulerZYX(n.x||0,n.y||0,n.z||0),o.transformA.setRotation(m);const h=o.transformB.getRotation();h.setEulerZYX(i.x||0,i.y||0,i.z||0),o.transformB.setRotation(h);const d=new Ammo.btSliderConstraint(t.ammo,e.ammo,o.transformA,o.transformB,!0);return d.setLowerLinLimit(r),d.setUpperLinLimit(a),d.setLowerAngLimit(c),d.setUpperAngLimit(l),this.physicsWorld.addConstraint(d),d}spring(t,e,s={}){const{stiffness:o=50,damping:n=.01,angularLock:i=!1,linearLowerLimit:r={},linearUpperLimit:a={}}=s,c=this.getTransform(t.ammo,e.ammo),l=new Ammo.btGeneric6DofSpringConstraint(t.ammo,e.ammo,c.transformA,c.transformB,!0);this.tmpBtVector3.setValue(r.x||0,r.y||0,r.z||0),l.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(a.x||0,a.y||0,a.z||0),l.setLinearUpperLimit(this.tmpBtVector3),i&&(this.tmpBtVector3.setValue(0,0,0),l.setAngularLowerLimit(this.tmpBtVector3),l.setAngularUpperLimit(this.tmpBtVector3));for(let t=0;t<3;t++)l.enableSpring(t,!0),l.setStiffness(t,o),l.setDamping(t,n);return this.physicsWorld.addConstraint(l),l}coneTwist(t,e,s={},o={}){const n=new Ammo.btTransform;n.setIdentity(),n.getOrigin().setValue((null==s?void 0:s.x)||0,(null==s?void 0:s.y)||0,(null==s?void 0:s.z)||0);const i=new Ammo.btTransform;i.setIdentity(),i.getOrigin().setValue((null==o?void 0:o.x)||0,(null==o?void 0:o.y)||0,(null==o?void 0:o.z)||0);this.getTransform(t.ammo,e.ammo);const r=new Ammo.btConeTwistConstraint(e.ammo,t.ammo,n,i);return r.setAngularOnly(!0),this.physicsWorld.addConstraint(r),r}dof(t,e,s={}){const{offset:o,center:n=!1}=s,i=Object.assign({x:0,y:0,z:0},o),r=this.getTransform(t.ammo,e.ammo,i,n),a=new Ammo.btGeneric6DofConstraint(t.ammo,e.ammo,r.transformA,r.transformB,!0),{linearLowerLimit:c,linearUpperLimit:l,angularLowerLimit:m,angularUpperLimit:h}=s,d=this.toAmmoV3(c),u=this.toAmmoV3(l),p=this.toAmmoV3(m,-Math.PI),y=this.toAmmoV3(h,Math.PI);return a.setLinearLowerLimit(d),a.setLinearUpperLimit(u),a.setAngularLowerLimit(p),a.setAngularUpperLimit(y),Ammo.destroy(d),Ammo.destroy(u),Ammo.destroy(p),Ammo.destroy(y),this.physicsWorld.addConstraint(a,!1),a}}var u=s(4),p=s(0);
/**
 * @author       Kevin Lee (https://github.com/InfiniteLee)
 * @copyright    Copyright (c) 2019 Kevin Lee; Project Url: https://github.com/InfiniteLee/three-to-ammo
 * @license      {@link https://github.com/InfiniteLee/three-to-ammo/blob/master/LICENSE|MPL-2.0}
 */
const y="box",f="cylinder",b="sphere",g="capsule",v="cone",x="hull",w="hacd",A="vhacd",V="mesh",_="heightfield",C="all",P="manual",M=c.a.prototype.hasOwnProperty("updateMatrices"),B=function(t,e){switch(e.type){case y:return O(t,e);case f:return E(t,e);case g:return T(t,e);case v:return S(t,e);case b:return j(t,e);case x:return D(t,e);case w:return k(t,e);case A:return z(t,e);case V:return L(t,e);case _:return R(t,e);default:return n()(e.type+" is not currently supported"),[]}},O=function(t,e){e.type=y,H(e),e.fit===C&&(e.halfExtents=N(t,U(t,e),e.minHalfExtent,e.maxHalfExtent));const s=new Ammo.btVector3(e.halfExtents.x,e.halfExtents.y,e.halfExtents.z),o=new Ammo.btBoxShape(s);return Ammo.destroy(s),W(o,e,G(t,e)),o},E=function(t,e){e.type=f,H(e),e.fit===C&&(e.halfExtents=N(t,U(t,e),e.minHalfExtent,e.maxHalfExtent));const s=new Ammo.btVector3(e.halfExtents.x,e.halfExtents.y,e.halfExtents.z),o=(()=>{switch(e.cylinderAxis){case"y":return new Ammo.btCylinderShape(s);case"x":return new Ammo.btCylinderShapeX(s);case"z":return new Ammo.btCylinderShapeZ(s)}return null})();return Ammo.destroy(s),W(o,e,G(t,e)),o},T=function(t,e){e.type=g,H(e),e.fit===C&&(e.halfExtents=N(t,U(t,e),e.minHalfExtent,e.maxHalfExtent));const{x:s,y:o,z:n}=e.halfExtents,i=(()=>{switch(e.cylinderAxis){case"y":return new Ammo.btCapsuleShape(Math.max(s,n),2*o);case"x":return new Ammo.btCapsuleShapeX(Math.max(o,n),2*s);case"z":return new Ammo.btCapsuleShapeZ(Math.max(s,o),2*n)}return null})();return W(i,e,G(t,e)),i},S=function(t,e){e.type=v,H(e),e.fit===C&&(e.halfExtents=N(t,U(t,e),e.minHalfExtent,e.maxHalfExtent));const{x:s,y:o,z:n}=e.halfExtents,i=(()=>{switch(e.cylinderAxis){case"y":return new Ammo.btConeShape(Math.max(s,n),2*o);case"x":return new Ammo.btConeShapeX(Math.max(o,n),2*s);case"z":return new Ammo.btConeShapeZ(Math.max(s,o),2*n)}return null})();return W(i,e,G(t,e)),i},j=function(t,e){let s;e.type=b,H(e),s=e.fit!==P||isNaN(e.sphereRadius)?I(t,e,U(t,e)):e.sphereRadius;const o=new Ammo.btSphereShape(s);return W(o,e,G(t,e)),o},D=function(){const t=new p.Vector3,e=new p.Vector3;return function(s,o){if(o.type=x,H(o),o.fit===P)return console.warn("cannot use fit: manual with type: hull"),null;const n=U(s,o),i=new Ammo.btVector3,r=new Ammo.btConvexHullShape;r.setMargin(o.margin),e.addVectors(n.max,n.min).multiplyScalar(.5);let a=0;F(s,o,t=>{a+=t.attributes.position.array.length/3});const c=o.hullMaxVertices||1e5;a>c&&console.warn(`too many vertices for hull shape; sampling ~${c} from ~${a} vertices`);const l=Math.min(1,c/a);F(s,o,(s,o)=>{Q(s,o);const n=s.attributes.position.array;for(let s=0;s<n.length;s+=3)Math.random()<=l&&(t.set(n[s],n[s+1],n[s+2]).applyMatrix4(o).sub(e),i.setValue(t.x,t.y,t.z),r.addPoint(i,s===n.length-3))});let m=r;if(r.getNumVertices()>=100){const t=new Ammo.btShapeHull(r);t.buildHull(o.margin),Ammo.destroy(r),m=new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()),t.numVertices()),Ammo.destroy(t)}return Ammo.destroy(i),W(m,o,G(s,o)),m}}(),k=function(){const t=new p.Vector3,e=new p.Vector3;return function(s,o){if(o.type=w,H(o),o.fit===P)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const n=U(s),i=G(s,o);let r=0,a=0;e.addVectors(n.max,n.min).multiplyScalar(.5),F(s,o,t=>{r+=t.attributes.position.array.length/3,t.index?a+=t.index.array.length/3:a+=t.attributes.position.array.length/9});const c=new Ammo.HACD;o.hasOwnProperty("compacityWeight")&&c.SetCompacityWeight(o.compacityWeight),o.hasOwnProperty("volumeWeight")&&c.SetVolumeWeight(o.volumeWeight),o.hasOwnProperty("nClusters")&&c.SetNClusters(o.nClusters),o.hasOwnProperty("nVerticesPerCH")&&c.SetNVerticesPerCH(o.nVerticesPerCH),o.hasOwnProperty("concavity")&&c.SetConcavity(o.concavity);const l=Ammo._malloc(3*r*8),m=Ammo._malloc(3*a*4);c.SetPoints(l),c.SetTriangles(m),c.SetNPoints(r),c.SetNTriangles(a);const h=l/8,d=m/4;F(s,o,(s,o)=>{Q(s,o);const n=s.attributes.position.array,i=s.index?s.index.array:null;for(let s=0;s<n.length;s+=3)t.set(n[s+0],n[s+1],n[s+2]).applyMatrix4(o).sub(e),Ammo.HEAPF64[h+s+0]=t.x,Ammo.HEAPF64[h+s+1]=t.y,Ammo.HEAPF64[h+s+2]=t.z;if(i)for(let t=0;t<i.length;t++)Ammo.HEAP32[d+t]=i[t];else for(let t=0;t<n.length/3;t++)Ammo.HEAP32[d+t]=t}),c.Compute(),Ammo._free(l),Ammo._free(m);const u=c.GetNClusters(),p=[];for(let t=0;t<u;t++){const e=new Ammo.btConvexHullShape;e.setMargin(o.margin);const s=c.GetNPointsCH(t),n=c.GetNTrianglesCH(t),r=Ammo._malloc(3*s*8),a=Ammo._malloc(3*n*4);c.GetCH(t,r,a);const l=r/8;for(let t=0;t<s;t++){const o=new Ammo.btVector3,n=Ammo.HEAPF64[l+3*t+0],i=Ammo.HEAPF64[l+3*t+1],r=Ammo.HEAPF64[l+3*t+2];o.setValue(n,i,r),e.addPoint(o,t===s-1),Ammo.destroy(o)}W(e,o,i),p.push(e)}return p}}(),z=function(){const t=new p.Vector3,e=new p.Vector3;return function(s,o){if(o.type=A,H(o),o.fit===P)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const n=U(s,o),i=G(s,o);let r=0,a=0;e.addVectors(n.max,n.min).multiplyScalar(.5),F(s,o,t=>{r+=t.attributes.position.count,t.index?a+=t.index.count/3:a+=t.attributes.position.count/3});const c=new Ammo.VHACD,l=new Ammo.Parameters;o.hasOwnProperty("resolution")&&l.set_m_resolution(o.resolution),o.hasOwnProperty("depth")&&l.set_m_depth(o.depth),o.hasOwnProperty("concavity")&&l.set_m_concavity(o.concavity),o.hasOwnProperty("planeDownsampling")&&l.set_m_planeDownsampling(o.planeDownsampling),o.hasOwnProperty("convexhullDownsampling")&&l.set_m_convexhullDownsampling(o.convexhullDownsampling),o.hasOwnProperty("alpha")&&l.set_m_alpha(o.alpha),o.hasOwnProperty("beta")&&l.set_m_beta(o.beta),o.hasOwnProperty("gamma")&&l.set_m_gamma(o.gamma),o.hasOwnProperty("pca")&&l.set_m_pca(o.pca),o.hasOwnProperty("mode")&&l.set_m_mode(o.mode),o.hasOwnProperty("maxNumVerticesPerCH")&&l.set_m_maxNumVerticesPerCH(o.maxNumVerticesPerCH),o.hasOwnProperty("minVolumePerCH")&&l.set_m_minVolumePerCH(o.minVolumePerCH),o.hasOwnProperty("convexhullApproximation")&&l.set_m_convexhullApproximation(o.convexhullApproximation),o.hasOwnProperty("oclAcceleration")&&l.set_m_oclAcceleration(o.oclAcceleration);const m=Ammo._malloc(3*r*8),h=Ammo._malloc(3*a*4);let d=m/8,u=h/4;F(s,o,(s,o)=>{Q(s,o);const n=s.attributes.position.array,i=s.index?s.index.array:null;for(let s=0;s<n.length;s+=3)t.set(n[s+0],n[s+1],n[s+2]).applyMatrix4(o).sub(e),Ammo.HEAPF64[d+0]=t.x,Ammo.HEAPF64[d+1]=t.y,Ammo.HEAPF64[d+2]=t.z,d+=3;if(i)for(let t=0;t<i.length;t++)Ammo.HEAP32[u]=i[t],u++;else for(let t=0;t<n.length/3;t++)Ammo.HEAP32[u]=t,u++}),c.Compute(m,3,r,h,3,a,l),Ammo._free(m),Ammo._free(h);const p=c.GetNConvexHulls(),y=[],f=new Ammo.ConvexHull;for(let t=0;t<p;t++){c.GetConvexHull(t,f);const e=f.get_m_nPoints(),s=(f.get_m_points(),new Ammo.btConvexHullShape);s.setMargin(o.margin);for(let t=0;t<e;t++){const o=new Ammo.btVector3,n=f.get_m_points(3*t+0),i=f.get_m_points(3*t+1),r=f.get_m_points(3*t+2);o.setValue(n,i,r),s.addPoint(o,t===e-1),Ammo.destroy(o)}W(s,o,i),y.push(s)}return Ammo.destroy(f),Ammo.destroy(c),y}}(),L=function(){const t=new p.Vector3,e=new p.Vector3,s=new p.Vector3;return function(o,n){if(n.type=V,H(n),n.fit===P)return console.warn("cannot use fit: manual with type: mesh"),null;const i=G(o,n),r=new Ammo.btVector3,a=new Ammo.btVector3,c=new Ammo.btVector3,l=new Ammo.btTriangleMesh(!0,!1);let m;return F(o,n,(o,n)=>{const i=o.attributes.position.array;if(o.index)for(let m=0;m<o.index.count;m+=3){const h=3*o.index.array[m],d=3*o.index.array[m+1],u=3*o.index.array[m+2];t.set(i[h],i[h+1],i[h+2]).applyMatrix4(n),e.set(i[d],i[d+1],i[d+2]).applyMatrix4(n),s.set(i[u],i[u+1],i[u+2]).applyMatrix4(n),r.setValue(t.x,t.y,t.z),a.setValue(e.x,e.y,e.z),c.setValue(s.x,s.y,s.z),l.addTriangle(r,a,c,!1)}else for(let o=0;o<i.length;o+=9)t.set(i[o+0],i[o+1],i[o+2]).applyMatrix4(n),e.set(i[o+3],i[o+4],i[o+5]).applyMatrix4(n),s.set(i[o+6],i[o+7],i[o+8]).applyMatrix4(n),r.setValue(t.x,t.y,t.z),a.setValue(e.x,e.y,e.z),c.setValue(s.x,s.y,s.z),l.addTriangle(r,a,c,!1)}),m=n.concave?new Ammo.btBvhTriangleMeshShape(l,!0,!0):new Ammo.btConvexTriangleMeshShape(l,!0),m.resources=[l],Ammo.destroy(r),Ammo.destroy(a),Ammo.destroy(c),W(m,n,i),m}}(),R=function(t,e){if(H(e),e.fit===C)return console.warn("cannot use fit: all with type: heightfield"),null;const s=e.heightfieldDistance||1,o=e.heightfieldData||[],n=e.heightScale||0,i=e.hasOwnProperty("upAxis")?e.upAxis:1,r=(()=>{switch(e.heightDataType){case"short":return Ammo.PHY_SHORT;case"float":default:return Ammo.PHY_FLOAT}})(),a=!e.hasOwnProperty("flipQuadEdges")||e.flipQuadEdges,c=o.length,l=c>0?o[0].length:0,m=Ammo._malloc(c*l*4),h=m/4;let d=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,p=0;for(let t=0;t<c;t++)for(let e=0;e<l;e++){const s=o[t][e];Ammo.HEAPF32[h+p]=s,p++,d=Math.min(d,s),u=Math.max(u,s)}const y=new Ammo.btHeightfieldTerrainShape(l,c,m,n,d,u,i,r,a),f=new Ammo.btVector3(s,1,s);return y.setLocalScaling(f),Ammo.destroy(f),y.heightfieldData=m,W(y,e),y};function H(t){t.fit=t.hasOwnProperty("fit")?t.fit:C,t.type=t.type||x,t.minHalfExtent=t.hasOwnProperty("minHalfExtent")?t.minHalfExtent:0,t.maxHalfExtent=t.hasOwnProperty("maxHalfExtent")?t.maxHalfExtent:Number.POSITIVE_INFINITY,t.cylinderAxis=t.cylinderAxis||"y",t.margin=t.hasOwnProperty("margin")?t.margin:.05,t.includeInvisible=!!t.hasOwnProperty("includeInvisible")&&t.includeInvisible,t.offset||(t.offset=new p.Vector3),t.orientation||(t.orientation=new p.Quaternion)}const W=function(t,e,s){if(t.type=e.type,t.setMargin(e.margin),t.destroy=()=>{for(let e of t.resources||[])Ammo.destroy(e);t.heightfieldData&&Ammo._free(t.heightfieldData),Ammo.destroy(t)},s){const e=new Ammo.btVector3(s.x,s.y,s.z);t.setLocalScaling(e),Ammo.destroy(e)}},F=function(){const t=new p.Matrix4,e=new p.Matrix4,s=new p.BufferGeometry;return function(o,n,i){e.getInverse(o.matrixWorld),o.traverse(n=>{n.isMesh&&(n===o?t.identity():(M&&n.updateMatrices(),t.multiplyMatrices(e,n.matrixWorld)),i(n.geometry.isBufferGeometry?n.geometry:s.fromGeometry(n.geometry),t))})}}(),G=function(t,e){const{scale:s}=t;return s},I=function(){const t=new p.Vector3,e=new p.Vector3;return function(s,o,n){let i=0,{x:r,y:a,z:c}=n.getCenter(e);return F(s,o,(e,s)=>{const o=e.attributes.position.array;for(let e=0;e<o.length;e+=3){t.set(o[e],o[e+1],o[e+2]).applyMatrix4(s);const n=r-t.x,l=a-t.y,m=c-t.z;i=Math.max(i,n*n+l*l+m*m)}}),Math.sqrt(i)}}(),N=function(t,e,s,o){return(new p.Vector3).subVectors(e.max,e.min).multiplyScalar(.5).clampScalar(s,o)},U=function(){const t=new p.Vector3;return function(e,s){const o=new p.Box3;let n=1/0,i=1/0,r=1/0,a=-1/0,c=-1/0,l=-1/0;return o.min.set(0,0,0),o.max.set(0,0,0),F(e,s,(e,s)=>{const o=e.attributes.position.array;for(let e=0;e<o.length;e+=3)t.set(o[e],o[e+1],o[e+2]).applyMatrix4(s),t.x<n&&(n=t.x),t.y<i&&(i=t.y),t.z<r&&(r=t.z),t.x>a&&(a=t.x),t.y>c&&(c=t.y),t.z>l&&(l=t.z)}),o.min.set(n,i,r),o.max.set(a,c,l),o}}(),Q=(t,e)=>{t.computeBoundingBox();const s=new p.Vector3;t.boundingBox.getCenter(s),e.makeTranslation(s.x,s.y,s.z)};var q=s(11),Y=s.n(q);
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
class X extends u.EventEmitter{addCollider(t,e,s){t.body&&e.body&&(t.body.checkCollisions=!0,e.body.checkCollisions=!0,this.on("collision",o=>{var n,i;const{bodies:r,event:a}=o;(null===(n=r[0])||void 0===n?void 0:n.name)&&(null===(i=r[1])||void 0===i?void 0:i.name)&&(null==t?void 0:t.name)&&(null==e?void 0:e.name)&&(r[0].name===t.name&&r[1].name===e.name||r[1].name===t.name&&r[0].name===e.name)&&s(a)}))}}
/**
 * @author       Kevin Lee (https://github.com/InfiniteLee)
 * @copyright    Copyright (c) 2019 Kevin Lee; Project Url: https://github.com/InfiniteLee/ammo-debug-drawer
 * @license      {@link https://github.com/InfiniteLee/ammo-debug-drawer/blob/master/LICENSE|MPL-2.0}
 */const Z=1,$=32768;var K=class{constructor(t,e,s={}){this.scene=t,this.world=e,this.options=s,this.debugDrawMode=s.debugDrawMode||Z;const o=this.debugDrawMode&$||!1,n=s.maxBufferSize||1e6;this.geometry=new p.BufferGeometry;const i=new Float32Array(3*n),r=new Float32Array(3*n);this.geometry.setAttribute("position",new p.BufferAttribute(i,3).setUsage(p.StaticDrawUsage)),this.geometry.setAttribute("color",new p.BufferAttribute(r,3).setUsage(p.StaticDrawUsage)),this.index=0;const a=new p.LineBasicMaterial({vertexColors:!0,depthTest:!o});this.mesh=new p.LineSegments(this.geometry,a),o&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(0!=this.index&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,e,s){const o=Ammo.HEAPF32,n=o[(s+0)/4],i=o[(s+4)/4],r=o[(s+8)/4],a=o[(t+0)/4],c=o[(t+4)/4],l=o[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,a,c,l),this.geometry.attributes.color.setXYZ(this.index++,n,i,r);const m=o[(e+0)/4],h=o[(e+4)/4],d=o[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,m,h,d),this.geometry.attributes.color.setXYZ(this.index++,n,i,r)}drawContactPoint(t,e,s,o,n){const i=Ammo.HEAPF32,r=i[(n+0)/4],a=i[(n+4)/4],c=i[(n+8)/4],l=i[(t+0)/4],m=i[(t+4)/4],h=i[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,l,m,h),this.geometry.attributes.color.setXYZ(this.index++,r,a,c);const d=i[(e+0)/4]*s,u=i[(e+4)/4]*s,p=i[(e+8)/4]*s;this.geometry.attributes.position.setXYZ(this.index,l+d,m+u,h+p),this.geometry.attributes.color.setXYZ(this.index++,r,a,c)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,e){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}};const J=function(t,e){this.minSizeForBreak=t||1.4,this.smallDelta=e||1e-4,this.tempLine1=new p.Line3,this.tempPlane1=new p.Plane,this.tempPlane2=new p.Plane,this.tempPlane_Cut=new p.Plane,this.tempCM1=new p.Vector3,this.tempCM2=new p.Vector3,this.tempVector3=new p.Vector3,this.tempVector3_2=new p.Vector3,this.tempVector3_3=new p.Vector3,this.tempVector3_P0=new p.Vector3,this.tempVector3_P1=new p.Vector3,this.tempVector3_P2=new p.Vector3,this.tempVector3_N0=new p.Vector3,this.tempVector3_N1=new p.Vector3,this.tempVector3_AB=new p.Vector3,this.tempVector3_CB=new p.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(var s=0;s<900;s++)this.segments[s]=!1};var tt;J.prototype={constructor:J,prepareBreakableObject:function(t,e,s,o,n){t.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."),t.userData.ammoPhysicsData={};var i=t.userData.ammoPhysicsData;i.mass=e,i.velocity=s.clone(),i.angularVelocity=o.clone(),i.breakable=n},subdivideByImpact:function(t,e,s,o,n){var i=[],r=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(e,s),r.setFromCoplanarPoints(e,t.position,this.tempVector3);var c=n+o,l=this;return function n(m,h,d,u){if(Math.random()<.05*u||u>c)i.push(m);else{var p=Math.PI;0===u?(a.normal.copy(r.normal),a.constant=r.constant):u<=o?(p=(d-h)*(.2+.6*Math.random())+h,l.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(s,p).add(e),a.setFromCoplanarPoints(e,l.tempVector3,l.tempVector3_2)):(p=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,l.tempVector3_2.copy(e).sub(m.position).applyAxisAngle(s,p).add(m.position),l.tempVector3_3.copy(s).add(m.position),a.setFromCoplanarPoints(m.position,l.tempVector3_3,l.tempVector3_2)),l.cutByPlane(m,a,l.tempResultObjects);var y=l.tempResultObjects.object1,f=l.tempResultObjects.object2;y&&n(y,h,p,u+1),f&&n(f,p,d,u+1)}}(t,0,2*Math.PI,0),i},cutByPlane:function(t,e,s){var o=t.geometry,i=o.attributes.position.array,r=o.attributes.normal.array,a=i.length/3,c=a/3,l=o.getIndex();function m(t,e){var s=3*t+e;return l?l[s]:s}l&&(c=(l=l.array).length/3);for(var h=[],d=[],u=this.smallDelta,y=a*a,f=0;f<y;f++)this.segments[f]=!1;var b=this.tempVector3_P0,g=this.tempVector3_P1,v=this.tempVector3_N0,x=this.tempVector3_N1;for(f=0;f<c-1;f++){var w=m(f,0),A=m(f,1),V=m(f,2);v.set(r[w],r[w]+1,r[w]+2);for(var _=f+1;_<c;_++){var C=m(_,0),P=m(_,1),M=m(_,2);x.set(r[C],r[C]+1,r[C]+2),1-v.dot(x)<u&&(w===C||w===P||w===M?A===C||A===P||A===M?(this.segments[w*a+A]=!0,this.segments[A*a+w]=!0):(this.segments[V*a+w]=!0,this.segments[w*a+V]=!0):A!==C&&A!==P&&A!==M||(this.segments[V*a+A]=!0,this.segments[A*a+V]=!0))}}var B=this.tempPlane_Cut;t.updateMatrix(),J.transformPlaneToLocalSpace(e,t.matrix,B);for(f=0;f<c;f++)for(var O=m(f,0),E=m(f,1),T=m(f,2),S=0;S<3;S++){var j=0===S?O:1===S?E:T,D=0===S?E:1===S?T:O;if(!this.segments[j*a+D]){this.segments[j*a+D]=!0,this.segments[D*a+j]=!0,b.set(i[3*j],i[3*j+1],i[3*j+2]),g.set(i[3*D],i[3*D+1],i[3*D+2]);var k=0;(z=B.distanceToPoint(b))>u?(k=2,d.push(b.clone())):z<-u?(k=1,h.push(b.clone())):(k=3,h.push(b.clone()),d.push(b.clone()));var z,L=0;if((z=B.distanceToPoint(g))>u?(L=2,d.push(g.clone())):z<-u?(L=1,h.push(g.clone())):(L=3,h.push(g.clone()),d.push(g.clone())),1===k&&2===L||2===k&&1===L){this.tempLine1.start.copy(b),this.tempLine1.end.copy(g);var R=new p.Vector3;if(void 0===(R=B.intersectLine(this.tempLine1,R)))return console.error("Internal error: segment does not intersect plane."),s.segmentedObject1=null,s.segmentedObject2=null,0;h.push(R),d.push(R.clone())}}}var H=.5*t.userData.ammoPhysicsData.mass;this.tempCM1.set(0,0,0);var W=0,F=h.length;if(F>0){for(f=0;f<F;f++)this.tempCM1.add(h[f]);this.tempCM1.divideScalar(F);for(f=0;f<F;f++){(N=h[f]).sub(this.tempCM1),W=Math.max(W,N.x,N.y,N.z)}this.tempCM1.add(t.position)}this.tempCM2.set(0,0,0);var G=0,I=d.length;if(I>0){for(f=0;f<I;f++)this.tempCM2.add(d[f]);this.tempCM2.divideScalar(I);for(f=0;f<I;f++){var N;(N=d[f]).sub(this.tempCM2),G=Math.max(G,N.x,N.y,N.z)}this.tempCM2.add(t.position)}var U=null,Q=null,q=0;if(F>4)try{(U=new p.Mesh(new p.ConvexBufferGeometry(h),t.material)).position.copy(this.tempCM1),U.quaternion.copy(t.quaternion),U.userData=t.userData,this.prepareBreakableObject(U,H,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*W>this.minSizeForBreak),q++}catch(t){n()("Error in ConvexObjectBreaker.ts"),n()(t)}if(I>4)try{(Q=new p.Mesh(new p.ConvexBufferGeometry(d),t.material)).position.copy(this.tempCM2),Q.quaternion.copy(t.quaternion),Q.userData=t.userData,this.prepareBreakableObject(Q,H,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*G>this.minSizeForBreak),q++}catch(t){n()("Error in ConvexObjectBreaker.ts"),n()(t)}return s.object1=U,s.object2=Q,q}},J.transformFreeVector=function(t,e){var s=t.x,o=t.y,n=t.z,i=e.elements;return t.x=i[0]*s+i[4]*o+i[8]*n,t.y=i[1]*s+i[5]*o+i[9]*n,t.z=i[2]*s+i[6]*o+i[10]*n,t},J.transformFreeVectorInverse=function(t,e){var s=t.x,o=t.y,n=t.z,i=e.elements;return t.x=i[0]*s+i[1]*o+i[2]*n,t.y=i[4]*s+i[5]*o+i[6]*n,t.z=i[8]*s+i[9]*o+i[10]*n,t},J.transformTiedVectorInverse=function(t,e){var s=t.x,o=t.y,n=t.z,i=e.elements;return t.x=i[0]*s+i[1]*o+i[2]*n-i[12],t.y=i[4]*s+i[5]*o+i[6]*n-i[13],t.z=i[8]*s+i[9]*o+i[10]*n-i[14],t},J.transformPlaneToLocalSpace=(tt=new p.Vector3,function(t,e,s){s.normal.copy(t.normal),s.constant=t.constant;var o=J.transformTiedVectorInverse(t.coplanarPoint(tt),e);J.transformFreeVectorInverse(s.normal,e),s.constant=-o.dot(s.normal)});var et=s(8),st=s(5),ot=s.n(st),nt=s(9),it=s(6),rt=s.n(it);
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
class at{constructor(t){this.physics=t}setRayFromWorld(t=0,e=0,s=0){this._btRayFrom.setValue(t,e,s)}setRayToWorld(t=0,e=0,s=0){this._btRayTo.setValue(t,e,s)}hasHit(){return this._btRayCallback.hasHit()}rayTest(){void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback),this._btRayCallback="closest"===this.type?new Ammo.ClosestRayResultCallback(this._btRayFrom,this._btRayTo):new Ammo.AllHitsRayResultCallback(this._btRayFrom,this._btRayTo),this.physics.physicsWorld.rayTest(this._btRayFrom,this._btRayTo,this._btRayCallback)}destroy(){void 0!==this._btRayFrom&&Ammo.destroy(this._btRayFrom),void 0!==this._btRayTo&&Ammo.destroy(this._btRayTo),void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback)}}class ct{constructor(t){this.physics=t,this.type="closest",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}class lt{constructor(t){this.physics=t,this.type="allHits",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}rt()(ct,[at,
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
class{constructor(t){this.physics=t}getHitPointWorld(){const t=this._btRayCallback.get_m_hitPointWorld();return{x:t.x(),y:t.y(),z:t.z()}}getHitNormalWorld(){const t=this._btRayCallback.get_m_hitNormalWorld();return{x:t.x(),y:t.y(),z:t.z()}}getCollisionObject(){const t=(e=this._btRayCallback.get_m_collisionObject(),Object.values(e)[0]);var e;return this.physics.objectsAmmo[t]}}
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */]),rt()(lt,[at,class{constructor(t){this.physics=t}getHitPointsWorld(){const t=this._btRayCallback.get_m_hitPointWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const o=t.at(s);e.push({x:o.x(),y:o.y(),z:o.z()})}return e}getHitPointWorld(){return console.warn("[enable3d] Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"),this.getHitPointsWorld()}getHitNormalsWorld(){const t=this._btRayCallback.get_m_hitNormalWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const o=t.at(s);e.push({x:o.x(),y:o.y(),z:o.z()})}return e}getCollisionObjects(){const t=[],e=this._btRayCallback.get_m_collisionObjects();for(let o=e.size()-1;o>=0;o--){const n=(s=e.at(o),Object.values(s)[0]);t.push(this.physics.objectsAmmo[n])}var s;return t}}]);class mt{constructor(t=!0){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){let e=("undefined"==typeof performance?Date:performance).now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class ht extends u.EventEmitter{constructor(t,e={}){super(),this.scene=t,this.config=e,this.rigidBodies=[],this.objectsAmmo={},this.earlierDetectedCollisions=[],this.gravity=e.gravity||{x:0,y:-9.81,z:0},this.isHeadless="headless"===t,this.tmpEuler=new p.Euler,this.tmpQuaternion=new p.Quaternion,this.tmpVector3=new p.Vector3,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new p.Vector3,this.impactPoint=new p.Vector3,this.impactNormal=new p.Vector3,"headless"!==t&&(this.defaultMaterial=new ot.a),this.start()}destroy(t){var e;const s=Object.keys(t).includes("body")?t.body:t;if(void 0===(null==s?void 0:s.ammo))return;const o=Object.values(s.ammo)[0],n=Object.values(s.ammo)[1],i=this.objectsAmmo[o];if(o&&n&&i&&(null===(e=null==i?void 0:i.body)||void 0===e?void 0:e.ammo)){this.physicsWorld.removeRigidBody(i.body.ammo),i.body.destructor(),i.body=void 0,i.hasBody=!1,delete this.objectsAmmo[o];for(let t=0;t<this.rigidBodies.length;t++)this.rigidBodies[t].name===n&&(this.rigidBodies.splice(t,1),t--)}"headless"===this.scene&&i&&(i=null)}setup(){if(this.setupPhysicsWorld(),"headless"!==this.scene){this.convexBreaker=new J,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new X,this.factory=new Y.a(this.scene),this.shapes=new h(this.factory,(t,e)=>this.addExisting(t,e)),this.constraints=new d(this.tmpTrans,this.physicsWorld),"headless"!==this.scene&&(this.debugDrawer=new K(this.scene,this.physicsWorld,{}))}updateDebugger(){"headless"!==this.scene&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,e=new Ammo.btDefaultCollisionConfiguration,s=new Ammo.btCollisionDispatcher(e),o=new Ammo.btDbvtBroadphase,n=new Ammo.btSequentialImpulseConstraintSolver;this.physicsWorld=new Ammo.btDiscreteDynamicsWorld(s,o,n,e),this.physicsWorld.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),this.dispatcher=s,this.tmpTrans=new Ammo.btTransform}createDebrisFromBreakableObject(t,e){"headless"!==this.scene&&(t.material=this.defaultMaterial.get(),t.shape="hull",t.fragmentDepth=e.fragmentDepth+1,this.scene.add(t),this.addExisting(t),t.body.breakable=!1,setTimeout(()=>{t.body.breakable=!0},2500))}removeDebris(t){"headless"!==this.scene&&(this.scene.remove(t),this.physicsWorld.removeRigidBody(t.body.ammo),delete this.objectsAmmo[t.ptr])}update(t){var e,s;this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const o=[],n=t/1e3;this.physicsWorld.stepSimulation(n,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let t=0,e=this.rigidBodies.length;t<e;t++){const e=this.rigidBodies[t],s=e.body.ammo.getMotionState();if(s)if(s.getWorldTransform(this.tmpTrans),e.body.didUpdate&&(e.body._emitUpdateEvents&&e.body.eventEmitter.emit("update"),e.body.didUpdate=!1),e.body.ammo.isKinematicObject()&&e.body.needUpdate)e.getWorldQuaternion(this.tmpQuaternion),e.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.tmpTrans.setOrigin(this.tmpBtVector3),this.tmpTrans.setRotation(this.tmpBtQuaternion),s.setWorldTransform(this.tmpTrans),e.body.needUpdate=!1;else{let t=this.tmpTrans.getOrigin(),s=this.tmpTrans.getRotation(),o=e.body.offset;e.position.set(t.x()+o.x,t.y()+o.y,t.z()+o.z),e.quaternion.set(s.x(),s.y(),s.z(),s.w())}}for(let t=0,n=this.dispatcher.getNumManifolds();t<n;t++){const n=this.dispatcher.getManifoldByIndexInternal(t),i=Object.keys(n.getBody0())[0],r=Ammo.castObject(n.getBody0(),Ammo.btRigidBody),a=Ammo.castObject(n.getBody1(),Ammo.btRigidBody);if(""===r.name&&""===a.name)continue;const c=r[i],l=a[i],m=this.objectsAmmo[c],h=this.objectsAmmo[l];if(!m||!h)continue;const d=m.body.breakable,u=h.body.breakable,p=null===(e=m.body)||void 0===e?void 0:e.checkCollisions,y=null===(s=h.body)||void 0===s?void 0:s.checkCollisions;if(!(p||y||d||u))continue;let f=!1,b=0,g="start";for(let t=0,e=n.getNumContacts();t<e;t++){const e=n.getContactPoint(t);if(e.getDistance()<=0){f=!0;const t=e.getAppliedImpulse(),s=e.get_m_positionWorldOnB(),n=e.get_m_normalWorldOnB();if(p||y){const t=[m.name,h.name].sort(),e=`${t[0]}__${t[1]}`;this.earlierDetectedCollisions.find(t=>t.combinedName===e)&&(g="collision"),o.find(t=>t.combinedName===e)||(o.push({combinedName:e,collision:!0}),this.collisionEvents.emit("collision",{bodies:[m,h],event:g}))}t>=b&&(b=t,(d||u)&&(this.impactPoint.set(s.x(),s.y(),s.z()),this.impactNormal.set(n.x(),n.y(),n.z())));break}}if(!f)continue;if(!d&&!u)continue;const v=5,x=2;if(this.emptyV3.set(0,0,0),m.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:d,physicsBody:r},h.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:u,physicsBody:a},void 0===m.fragmentDepth&&(m.fragmentDepth=0),void 0===h.fragmentDepth&&(h.fragmentDepth=0),d&&b>v&&m.fragmentDepth<x){const t=this.convexBreaker.subdivideByImpact(m,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=r.getLinearVelocity(),o=r.getAngularVelocity(),n=t[s];n.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),n.userData.ammoPhysicsData.angularVelocity.set(o.x(),o.y(),o.z()),this.createDebrisFromBreakableObject(n,m)}this.objectsToRemove[this.numObjectsToRemove++]=m}if(u&&b>v&&h.fragmentDepth<x){const t=this.convexBreaker.subdivideByImpact(h,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=a.getLinearVelocity(),o=a.getAngularVelocity(),n=t[s];n.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),n.userData.ammoPhysicsData.angularVelocity.set(o.x(),o.y(),o.z()),this.createDebrisFromBreakableObject(n,h)}this.objectsToRemove[this.numObjectsToRemove++]=h}}for(let t=0;t<this.numObjectsToRemove;t++)this.removeDebris(this.objectsToRemove[t]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach(t=>{const{combinedName:e}=t;if(!o.find(t=>t.combinedName===e)){const t=e.split("__"),s=this.rigidBodies.find(e=>e.name===t[0]),o=this.rigidBodies.find(e=>e.name===t[1]),n="end";s&&o&&this.collisionEvents.emit("collision",{bodies:[s,o],event:n})}}),this.earlierDetectedCollisions=[...o]}setGravity(t=0,e=-9.8,s=0){this.tmpBtVector3.setValue(t,e,s),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){"undefined"!=typeof Ammo?"function"==typeof Ammo?Ammo().then(()=>{this.setup()}):this.setup():n()("Are you sure you included ammo.js?")}get add(){return{collider:(t,e,s)=>this.collisionEvents.addCollider(t,e,s),constraints:this.constraints.addConstraints,existing:(t,e)=>this.addExisting(t,e),plane:(t={},e={})=>this.shapes.addPlane(t,e),sphere:(t={},e={})=>this.shapes.addSphere(t,e),ground:(t={},e={})=>this.shapes.addGround(t,e),box:(t={},e={})=>this.shapes.addBox(t,e),cylinder:(t={},e={})=>this.shapes.addCylinder(t,e),cone:(t={},e={})=>this.shapes.addCone(t,e),torus:(t={},e={})=>this.shapes.addTorus(t,e),extrude:(t,e={})=>this.shapes.addExtrude(t,e),raycaster:(t="closest")=>"closest"===t?new ct(this):new lt(this)}}prepareThreeObjectForCollisionShape(t,e={}){var s,o;const{position:i,quaternion:r,hasBody:a}=t,{autoCenter:c=!1}=e,l={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let m="unknown";const h=(null===(s=t.geometry)||void 0===s?void 0:s.type)||"unknown";/box/i.test(h)?m="box":/cone/i.test(h)?m="cone":/cylinder/i.test(h)?m="cylinder":/extrude/i.test(h)?m="extrude":/plane/i.test(h)?m="plane":/sphere/i.test(h)?m="sphere":/torus/i.test(h)&&(m="torus");let d=Object.assign(Object.assign({},l),null===(o=null==t?void 0:t.geometry)||void 0===o?void 0:o.parameters);return e.shape?(d=Object.assign(Object.assign({},l),e),m=e.shape):t.shape&&(m=t.shape),Object.keys(d).forEach(t=>{void 0===d[t]&&l[t]&&(d[t]=l[t])}),c&&t.geometry.center(),"extrude"===m&&(m="hacd"),"mesh"!==m&&"convex"!==m||(m="convexMesh"),"concave"===m&&(m="concaveMesh"),"unknown"===m&&(n()(`Shape for ${null==t?void 0:t.name} not recognized! Will fallback to box.`),m="box"),{shape:m,params:d,object:t}}createCollisionShape(t,e,s){const o=(null==s?void 0:s.quaternion)?null==s?void 0:s.quaternion:new p.Quaternion(0,0,0,1);let n;switch(t){case"box":n=new Ammo.btBoxShape(new Ammo.btVector3(e.width/2,e.height/2,e.depth/2));break;case"sphere":n=new Ammo.btSphereShape(e.radius);break;case"cylinder":n=new Ammo.btCylinderShape(new Ammo.btVector3(e.radiusTop,e.height/2,0));break;case"cone":n=new Ammo.btConeShape(e.radius,e.height);break;case"torus":n=((t,e)=>{const{radius:s=1,tube:o=.4,tubularSegments:n=8}=t,i=Math.PI,r=n,a=Math.sqrt(2*o*o-2*o*o*Math.cos(2*i/r)),c=new Ammo.btVector3(o,i/r+.5*a,o),l=new Ammo.btCylinderShape(c);l.setMargin(.05);const m=new Ammo.btCompoundShape,h=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,s,0),u=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let t=0;t<r;t++){const e=2*t*i/r,s=d.rotate(h,e),o=new Ammo.btTransform;u.setRotation(h,e+Math.PI/2),o.setIdentity(),o.setOrigin(s),o.setRotation(u),m.addChildShape(o,l)}return m})(e,o);break;case"capsule":n=new Ammo.btCapsuleShape(e.radius,e.height);break;case"plane":n=B(s,Object.assign({type:"mesh",concave:!1},e.collider));break;case"hull":n=B(s,Object.assign({type:"hull"},e.collider));break;case"hacd":n=B(s,Object.assign({type:"hacd"},e.collider));break;case"vhacd":n=B(s,Object.assign({type:"vhacd"},e.collider));break;case"convexMesh":n=B(s,Object.assign({type:"mesh",concave:!1},e.collider));break;case"concaveMesh":n=B(s,Object.assign({type:"mesh",concave:!0},e.collider))}const{x:i,y:r,z:a}=e;return(i||r||a)&&(n.offset={x:i||0,y:r||0,z:a||0}),Array.isArray(n)&&(n=this.mergeCollisionShapesToCompoundShape(n)),n}mergeCollisionShapesToCompoundShape(t){const e=new Ammo.btCompoundShape;return t.forEach(t=>{const{offset:s}=t,o=new Ammo.btTransform;o.setIdentity(),s&&o.setOrigin(new Ammo.btVector3(s.x||0,s.y||0,s.z||0)),e.addChildShape(o,t)}),e}addExisting(t,e={}){const{hasBody:s}=t;if(s)return void console.warn(`[Enable3d]: Object "${t.name}" already has a physical body!`);const{position:o,quaternion:n}=t,{shape:i="unknown",compound:r=[],mass:a=1,collisionFlags:c=0,offset:l,breakable:m=!1,addChildren:h=!0}=e;if(r.length>=1){const e=r.map(t=>this.createCollisionShape(t.shape,t)),s=this.mergeCollisionShapesToCompoundShape(e),o=this.collisionShapeToRigidBody(s,t.position,t.quaternion,1);return void this.addRigidBodyToWorld(t,o)}const d=[];if("unknown"!==i||t.isMesh){const s=this.prepareThreeObjectForCollisionShape(t,e),o=this.createCollisionShape(s.shape,s.params,s.object);d.push(o)}if("unknown"===i&&h&&t.children.length>=1&&t.children.forEach(t=>{if(t.isMesh){const e=this.prepareThreeObjectForCollisionShape(t),s=this.createCollisionShape(e.shape,e.params,e.object);s.offset=t.position.clone(),d.push(s)}}),0===d.length){const s=this.prepareThreeObjectForCollisionShape(t,e),o=this.createCollisionShape(s.shape,s.params,s.object);d.push(o)}const u=1===d.length?d[0]:this.mergeCollisionShapesToCompoundShape(d),p=this.collisionShapeToRigidBody(u,o,n,a);this.addRigidBodyToWorld(t,p,c,m,l)}addRigidBodyToWorld(t,e,s=0,o,n){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(e);const i=Object.values(e)[0];e.name=t.name,t.body=new r.a(this,e),t.hasBody=!0,t.ptr=i,this.objectsAmmo[i]=t,o&&(t.body.breakable=!0),n&&(t.body.offset=Object.assign({x:0,y:0,z:0},n)),t.body.setCollisionFlags(s)}collisionShapeToRigidBody(t,e,s,o=1){const n=new Ammo.btTransform;n.setIdentity(),n.setOrigin(new Ammo.btVector3(e.x,e.y,e.z)),n.setRotation(new Ammo.btQuaternion(s.x,s.y,s.z,s.w));const i=new Ammo.btDefaultMotionState(n),r=new Ammo.btVector3(0,0,0);o>0&&t.calculateLocalInertia(o,r);const a=new Ammo.btRigidBodyConstructionInfo(o,i,t,r),c=new Ammo.btRigidBody(a);return o>0&&c.setActivationState(4),c}}}])}));
//# sourceMappingURL=enable3d.ammoPhysics.0.20.0.min.js.map